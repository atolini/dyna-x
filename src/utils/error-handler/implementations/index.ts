import { ILogger } from '../../logger/contracts';
import { IResponseBuilder } from '../../response-builder/contracts';
import { DynamoErrorHandler } from './handlers/dynamo-error-handler';
import { IErrorActions } from '../contracts/i-error-actions';
import { S3ErrorHandler } from './handlers/s3-error-handler';
import { CognitoErrorHandler } from './handlers/cognito-error-handler';

/**
 * @class ErrorHandler
 * @implements {IErrorActions<T, R>}
 *
 * @template T The type of the response returned to the client.
 * @template R A response builder that implements `IResponseBuilder<T>`.
 *
 * Handles errors by delegating them to a specific error handler when available.
 *
 * This class tries to identify an appropriate handler among a predefined or custom set of handlers
 * (e.g., for DynamoDB, S3, Cognito) that can process the given error. If no suitable handler is found,
 * the error is logged and a generic internal server error response is returned.
 *
 * The constructor receives an object that implements the `IResponseBuilder<T>` interface,
 * which is responsible for building the response returned to the client. This approach makes
 * the `ErrorHandler` class flexible and reusable with different response types, depending on the context.
 *
 * @example
 * const errorHandler = new ErrorHandler<MyResponseType, MyResponseBuilder>(
 *   new MyResponseBuilder(),
 *   new MyLogger(),
 *   [new CustomErrorHandler()]
 * );
 * const response: MyResponseType = errorHandler.handleError(new Error('Some error occurred'));
 */
export class ErrorHandler<T, R extends IResponseBuilder<T>> {
  private handlers: IErrorActions<T, R>[]; // List of error handlers
  private logger: ILogger<any>; // Logger instance for error logging
  private resBuilder: R; // Response builder (used to create error responses)

  /**
   * Creates an instance of the ErrorHandler.
   *
   * @param resBuilder - The response builder used to create error responses.
   * @param logger - Optional logger instance to log errors.
   * @param handlers - Optional list of custom error handlers to process errors.
   */
  constructor(
    resBuilder: R,
    logger: ILogger<any>,
    handlers?: IErrorActions<T, R>[],
  ) {
    this.resBuilder = resBuilder;
    this.logger = logger;
    this.handlers = handlers ?? [
      new DynamoErrorHandler<T, R>(), // Default handler for DynamoDB-related errors
      new S3ErrorHandler<T, R>(), // Default handler for S3-related errors
      new CognitoErrorHandler<T, R>(), // Default handler for Cognito-related errors
    ];
  }

  /**
   * Handles errors by finding the appropriate handler from the list of registered handlers.
   * If a handler is found, it processes the error and returns a response.
   * If no handler is found, it logs the error and returns a generic internal error response.
   *
   * @param error - The error to be handled.
   * @returns The response generated by the handler, or a generic error response.
   *
   * @example
   * const response = errorHandler.handleError(new Error('Some error occurred'));
   */
  public handleError(error: Error): T {
    const handler = this.handlers.find((h) => h.canHandle(error));

    // If a handler is found, process the error using that handler
    if (handler) {
      return handler.handle(error, this.logger, this.resBuilder);
    }

    // If no handler is found, log a generic error
    this.logger.error({
      description:
        'An unexpected error occurred. Please check the application logs for more details.',
      message: error.message,
      name: error.name,
      error: error,
    });

    // Return a generic internal error response
    return this.resBuilder.internalError('Unhandled error') as T;
  }
}
